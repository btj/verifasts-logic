\documentclass{article}

\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{mathpartir}

\title{VeriFast's separation logic: a higher-order(ish) logic without laters for modular verification of fine-grained concurrent programs}

\author{Bart Jacobs\\
{\small KU Leuven, Dept. CS, DistriNet Research Group}\\
{\small \textsf{bart.jacobs@cs.kuleuven.be}}}

\definecolor{ghost}{HTML}{CC6600}

\newcommand{\gmapsto}{\mapsto_\mathsf{g}}
\newcommand{\annot}[1]{{\color{blue} #1}}
\newcommand{\ghost}[1]{{\color{ghost} #1}}
\newcommand{\internal}[1]{{\color{purple} #1}}

\newcommand{\llbrace}{\{\hspace{-3pt}[}
\newcommand{\rrbrace}{]\hspace{-3pt}\}}

\begin{document}

\maketitle

\begin{abstract}
We present the separation logic of our VeriFast tool for modular verification of single-threaded and multithreaded C, Java, and Rust programs. Since the complexities of the programming language are orthogonal to the logic, we present the logic in the context of a simple concurrent programming language.
\end{abstract}

\section{Programming language}

In order to focus on the complexities of the logic rather than those of the programming language, we present VeriFast's separation logic in the context of a trivial concurrent programming language whose syntax is given in Fig.~\ref{fig:program-syntax} and whose small-step operational semantics is given in Fig.~\ref{fig:program-steps}. An example program that allocates a memory cell, increments it twice in parallel, and then asserts that the cell's value equals two is shown in Fig.~\ref{fig:example}.

\begin{figure}
$$\begin{array}{l}
\mathbf{let}\ \mathsf{x} = \mathbf{cons}(0)\ \mathbf{in}\\
(\\
\quad \mathbf{FAA}(\mathsf{x}, 1)\\
||\\
\quad \mathbf{FAA}(\mathsf{x}, 1)\\
);\\
\mathbf{let}\ \mathsf{v} = {*}\mathsf{x}\ \mathbf{in}\\
\mathbf{assert}\ \mathsf{v} = 2
\end{array}$$
\caption{An example program. $\mathbf{cons}(0)$ allocates a memory cell, initializes it to 0, and returns its address. The $\mathbf{FAA}$ command performs a sequentially consistent atomic fetch-and-add operation. $c_1\,||\, c_2$ is the parallel composition of commands $c_1$ and $c_2$. $*\ell$ returns the value stored at address $\ell$.}\label{fig:example}
\end{figure}

\begin{figure}
$$\begin{array}{r @{\;} @{\;} l}
& z \in \mathbb{Z}, x \in \mathcal{X}\\
e ::= & z\ |\ x\\
c ::= & e\ |\ \mathbf{cons}(e)\ |\ \mathbf{FAA}(e, e)\ |\ {*}e\ |\ \mathbf{assert}\ e = e\\
| & \mathbf{let}\ x = c\ \mathbf{in}\ c\ |\ (c\;||\;c)
\end{array}$$
\caption{Syntax of the expressions $e$ and commands $c$ of the programming language. We assume a set $\mathcal{X}$ of program variable names. $c; c'$ is a shorthand for $\mathbf{let}\ \_ = c\ \mathbf{in}\ c'$, where $\_$ is a designated element of $\mathcal{X}$}\label{fig:program-syntax}
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule{
\ell \notin \mathrm{dom}\,h
}{
(h, \mathbf{cons}(v)) \rightarrow (h[\ell := v], \ell)
}
\and
\inferrule{
\ell \in \mathrm{dom}\,h
}{
(h, \mathbf{FAA}(\ell, z) \rightarrow (h[\ell := h(\ell) + z], h(\ell))
}
\and
\inferrule{
\ell \in \mathrm{dom}\,h
}{
(h, {*}\ell) \rightarrow (h, h(\ell))
}
\and
(h, \mathbf{assert}\ v = v) \rightarrow (h, 0)
\and
(h, \mathbf{let}\ x = v\ \mathbf{in}\ c) \rightarrow (h, c[v/x])
\and
\inferrule{
(h, c) \rightarrow (h', c')
}{
(h, \mathbf{let}\ x = c\ \mathbf{in}\ c'') \rightarrow (h, \mathbf{let}\ x = c'\ \mathbf{in}\ c'')
}
\and
\inferrule{
(h, c) \rightarrow (h', c')
}{
(h, (c\;||\;c'')) \rightarrow (h', (c'\;||\;c''))
}
\and
\inferrule{
(h, c) \rightarrow (h', c')
}{
(h, (c''\;||\;c)) \rightarrow (h', (c''\;||\;c'))
}
\and
(h, v\;||\;v') \rightarrow (h, 0)
\end{mathpar}
\caption{Small-step operational semantics of the programming language}\label{fig:program-steps}
\end{figure}

We define the multiset of threads of a command $c$ as follows:
$$\mathsf{threads}(c) = \left\{\begin{array}{l l}
\mathsf{threads}(c_1) & \textrm{if $c = \mathbf{let}\ x = c_1\ \mathbf{in}\ c_2$}\\
\mathsf{threads}(c_1) \uplus \mathsf{threads}(c_2) & \textrm{if $c = (c_1\;||\;c_2)$}\\
\llbrace c\rrbrace & \textrm{otherwise}
\end{array}\right.$$

We say a configuration $(h, c)$ is \emph{reducible} if it can make a step:
$$\inferrule{
(h, c) \rightarrow (h', c')
}{
\mathsf{red}\,(h, c)
}$$
We say a configuration is \emph{finished} if its command is a value.
$$\mathsf{finished}\,(h, v)$$
We say a configuration is \emph{okay} if each thread is either reducible or finished.
$$\inferrule{
\forall c_\mathsf{t} \in \mathsf{threads}(c).\;\mathsf{finished}\,(h, c_\mathsf{t}) \lor \mathsf{red}\,(h, c_\mathsf{t})
}{
\mathsf{ok}\,(h, c)
}$$
We say a configuration is \emph{safe} if each configuration reachable from it is okay.
$$\inferrule{
\forall h', c'.\;(h, c) \rightarrow^* (h', c') \Rightarrow \mathsf{ok}\,(h', c')
}{
\mathsf{safe}\,(h, c)
}$$
We say a program $c$ is safe if $(\emptyset, c)$ is safe. The goal of the logic we present here is to prove that a given program is safe. This implies that it does not access unallocated memory and that there are no assertion failures.\footnote{In fact, the logic also proves that there are no data races, but for simplicity we do not consider data races here.}

\section{Annotated programs}

When verifying a program with VeriFast, the user must first insert \emph{annotations}, specifically \emph{ghost declarations} and \emph{ghost commands}, to obtain an \emph{annotated program}. The syntax of ghost declarations and ghost commands is shown in Fig.~\ref{fig:annot-syntax}. An annotated version of the example program is shown in Fig.~\ref{fig:example-proof}. An annotated program may refer to ghost constructs declared in the \emph{VeriFast prelude}, shown in Fig.~\ref{fig:prelude}.

There are two kinds of ghost declarations: \emph{lemma type declarations} and \emph{predicate constructor declarations}. These give meaning to \emph{lemma type names} $t \in \mathcal{T}$ and \emph{predicate constructor names} $p \in \mathcal{P}$. Conceptually, a lemma type is a predicate over a \emph{lemma value} $\lambda \overline{g}.\;C$, a parameterized ghost command. A predicate constructor is a named, parameterized assertion. Applying a predicate constructor to an argument list produces a \emph{predicate value} $p(\overline{V})$.

Besides integers, lemma values, and predicate values, ghost values may be pairs of ghost values, unit values $()$, and finite sets of ghost values.

Resources may be shared among threads using \emph{atomic spaces} (analogous to Iris \emph{invariants} \cite{iris1,iris-ground-up}). An atomic space is (non-uniquely) identified by a \emph{name} (any ghost value) and an \emph{invariant} (a predicate value) (but there may be multiple atomic spaces with the same name and invariant at any given time). At any point in time, ownership of the stock of logical resources in the system is distributed among the threads and the atomic spaces. That is, at any point, each logical resource is owned either by exactly one thread or by exactly one atomic space, or has been leaked irrecoverably. (More precisely, given that fractional resources are supported, the bundles of resources owned by the threads and the atomic spaces sum up to a logic heap that contains each physical points-to chunk only once and each $\mathbf{atomic\_space}$ chunk only as many times as there atomic spaces with that name and invariant, etc.) Creating an atomic space transfers a bundle of resources satisfying the atomic space's invariant from the creating thread to the newly created atomic space. Opening an atomic space transfers the resources owned by the atomic space to the opening thread; closing an atomic space again transfers a bundle of resources satisfying the atomic space's invariant from the closing thread to the atomic space. Destroying an atomic space transfers ownership of the resources owned by the atomic space to the destroying thread. To destroy an atomic space, the destroying thread must have full ownership of the atomic space. To open it, only partial ownership is required. (To close it, no ownership is required. If no such atomic space exists, the resources are leaked.) To prevent the same atomic space from being opened when it is already open, the set of opened atomic spaces is tracked using an $\mathbf{atomic\_spaces}(S)$ chunk, where $S$ is a set of the name-invariant pairs of the atomic spaces that are currently open.\footnote{This means it is not possible to open two atomic spaces with the same name-invariant pair at at the same time, even if multiple such atomic spaces exist.}

Lemma type assertions assert that a given lemma value is of a given lemma type, applied to a given lemma type argument list. Such assertions are \emph{linear}. To call a lemma, a full lemma type chunk for that lemma must be available, and it becomes unavailable for the duration of the call. A lemma type chunk is produced by the $\mathbf{produce\_lem\_ptr\_chunk}$ ghost command. Since that command is not allowed inside lemmas, the stock of lemma type chunks in the system only decreases as the lemma call stack grows; absence of infinite lemma recursion follows trivially.\footnote{This is a simplification with respect to the actual VeriFast tool, which does support production of lemma type chunks inside lemmas, using a variant of the $\mathbf{produce\_lem\_ptr\_chunk}$ syntax that additionally takes a block of ghost code. The chunk is available only until the end of that block. Now, suppose there is an infinite lemma call stack. Since the program text contains only finitely many $\mathbf{produce\_lem\_ptr\_chunk}$ commands, among the lemmas that appear infinitely often in that call stack, there is one that is syntactically maximal, i.e. that is not itself contained within another lemma that also appears infinitely often. It follows that from some point on, the call stack contains no lemmas bigger than this maximal one. Since a lemma type chunk for a given lemma can only be produced by a bigger lemma (since the latter's body must contain a $\mathbf{produce\_lem\_ptr\_chunk}$ command producing the former's), the stock of lemma type chunks for this maximal lemma will, from that point on, only decrease, which leads to a contradiction. (Note: for measuring the size of a lemma, the size of contained lemma \emph{values} is not taken into account. It follows that substitution of values for ghost variables never affects the size of a lemma.)}

Intermediate results produced by ghost commands can be stored in \emph{ghost variables}, which are like program variables except that they are in a separate namespace and can therefore never hide a program variable.\footnote{In the actual VeriFast tool, they are in the same namespace, but VeriFast checks that real code never uses a ghost variable.} To facilitate reasoning about concurrent programs, annotated programs can furthermore allocate \emph{ghost cells}; these are like physical memory locations except that they are allocated in a separate \emph{ghost heap} and mutated using separate \emph{ghost cell mutation commands}.

\begin{figure}
$$\begin{array}{r @{\;} l r}
& t \in \mathcal{T} & \textrm{lemma type names}\\
& p \in \mathcal{P} & \textrm{predicate constructor names}\\
& g \in \mathcal{G} & \textrm{ghost variable names}\\
& \pi \in \mathbb{R}^+ & \textrm{fractions}\\
\textrm{ghost values $V$} ::= & z\ |\ (V, V)\ |\ ()\ |\ \{\overline{V}\}\\
| & p(\overline{V}) & \textrm{predicate values}\\
| & \lambda \overline{g}.\;C & \textrm{lemma values}\\
\textrm{ghost expressions $E$} ::= & V\ |\ x\ |\ g\ |\ E + E\\
| & p(\overline{E}) & \textrm{predicate constructor applications}\\
| & (E, E)\ |\ () & \textrm{pair expressions, empty tuple}\\
| & \emptyset\ |\ \{E\}\ |\ E \cup E\ |\ E \setminus E & \textrm{set expressions}\\
\textrm{assertions $a$} ::= & [\pi]E \mapsto E & \textrm{points-to assertions}\\
| & [\pi]E \gmapsto E & \textrm{ghost cell points-to assertions}\\
| & E() & \textrm{predicate assertions}\\
| & [\pi]\mathbf{atomic\_space}(E, E) & \textrm{atomic space assertions}\\
| & E : t(\overline{E}) & \textrm{lemma type assertions}\\
| & \exists g.\;a\\
| & \mathbf{atomic\_spaces}(E) & \textrm{atomic spaces assertions}\\
| & \internal{\mathbf{heap}(E)} & \textrm{heap chunk assertions}\\
\mathit{gdecl} ::= & \multicolumn{2}{@{} l @{}}{\mathbf{lem\_type}\ t(\overline{g}) = \mathbf{lem}(\overline{g})\ \mathbf{forall}\ \overline{g}\ \mathbf{req}\ a\ \mathbf{ens}\ a}\\
| & \mathbf{pred\_ctor}\ p(\overline{g})() = a\\
C ::= & \multicolumn{2}{@{} l @{}}{c\ |\ \mathbf{let}\ x = c\ \mathbf{in}\ C\ |\ \mathbf{glet}\ g = C\ \mathbf{in}\ C\ |\ E(\overline{E})}\\
| & \mathbf{gcons}(E)\ |\ {*}E \leftarrow_\mathsf{g} E\\
| & \mathbf{open}\ E()\ |\ \mathbf{close}\ E()\\
| & \multicolumn{2}{@{} l @{}}{\mathbf{create\_atomic\_space}(E, E)\ |\ \mathbf{destroy\_atomic\_space}(E, E)}\\
| & \multicolumn{2}{@{} l @{}}{\mathbf{open\_atomic\_space}(E, E)\ |\ \mathbf{close\_atomic\_space}(E, E)}\\
| & \multicolumn{2}{@{} l @{}}{\mathbf{produce\_lem\_ptr\_chunk}\ t(\overline{E})(\overline{g})\ \{\ C\ \}}\\
| & \internal{E \leftarrow_\mathsf{h} E} & \textrm{heap chunk update}\\
\end{array}$$
\caption{Syntax of ghost declarations $\mathit{gdecl}$ and annotated commands $C$. Heap chunk assertions and heap chunk update commands are \emph{internal}; they are not accepted by VeriFast in source code and are introduced here only for the sake of the soundness proof.}\label{fig:annot-syntax}
\end{figure}

\begin{figure}
$$\ghost{\begin{array}{@{} l @{}}
\mathbf{lem\_type}\ \mathsf{FAA\_op}(\mathsf{x}, \mathsf{n}, \mathsf{P}, \mathsf{Q}) = \mathbf{lem}()\\
\quad \mathbf{forall}\ \mathsf{v}\\
\quad \mathbf{req}\ \mathsf{x} \mapsto \mathsf{v} * \mathsf{P}()\\
\quad \mathbf{ens}\ \mathsf{x} \mapsto \mathsf{v} + \mathsf{n} * \mathsf{Q}()\\
\mathbf{lem\_type}\ \mathsf{FAA\_ghop}(\mathsf{x}, \mathsf{n}, \mathsf{pre}, \mathsf{post}) = \mathbf{lem}(\mathsf{op})\\
\quad \mathbf{forall}\ \mathsf{P}, \mathsf{Q}\\
\quad \mathbf{req}\ \mathbf{atomic\_spaces}(\emptyset) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, \mathsf{n}, \mathsf{P}, \mathsf{Q}) * \mathsf{P}() * \mathsf{pre}()\\
\quad \mathbf{ens}\ \mathbf{atomic\_spaces}(\emptyset) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, \mathsf{n}, \mathsf{P}, \mathsf{Q}) * \mathsf{Q}() * \mathsf{post}()\\
\end{array}}$$
\caption{The ghost prelude (built-in ghost declarations)}\label{fig:prelude}
\end{figure}

\begin{figure}
$$\begin{array}{l}
\ghost{\begin{array}{@{} l @{}}
\mathbf{pred\_ctor}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})() = \exists \mathsf{v1}, \mathsf{v2}.\;[1/2]\mathsf{g1} \gmapsto \mathsf{v1} * [1/2]\mathsf{g2} \gmapsto \mathsf{v2} * \mathsf{x} \mapsto \mathsf{v1} + \mathsf{v2}\\
\mathbf{pred\_ctor}\ \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})() = [1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 0\\
\mathbf{pred\_ctor}\ \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})() = [1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 1\\
\mathbf{pred\_ctor}\ \mathsf{pre2}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})() = [1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g2} \gmapsto 0\\
\mathbf{pred\_ctor}\ \mathsf{post2}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})() = [1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g2} \gmapsto 1
\end{array}}\\
\\
\mathbf{let}\ \mathsf{x} = \mathbf{cons}(0)\ \mathbf{in}\\
\ghost{\mathbf{glet}\ \mathsf{g1} = \mathbf{gcons}(0)\ \mathbf{in}}\\
\ghost{\mathbf{glet}\ \mathsf{g2} = \mathbf{gcons}(0)\ \mathbf{in}}\\
\ghost{\mathbf{close}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();}\\
\ghost{\mathbf{create\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));}\\
(\\
\quad \ghost{\begin{array}{@{} l @{}}
\mathbf{produce\_lem\_ptr\_chunk}\ \mathsf{FAA\_ghop}(\mathsf{x}, 1, \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}), \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}))(\mathsf{op})\ \{\\
\quad \mathbf{open}\ \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\\
\quad \mathbf{open\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));\ \mathbf{open}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\\
\quad \mathsf{op}();\\
\quad *\mathsf{g1} \leftarrow_\mathsf{g} 1;\\
\quad \mathbf{close}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\ \mathbf{close\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));\\
\quad \mathbf{close}\ \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})()\\
\};
\end{array}}\\
\quad \ghost{\mathbf{close}\ \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();}\\
\quad \mathbf{FAA}(\mathsf{x}, 1);\\
\quad \ghost{\mathbf{open}\ \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})()}\\
||\\
\quad \ghost{\begin{array}{@{} l @{}}
\mathbf{produce\_lem\_ptr\_chunk}\ \mathsf{FAA\_ghop}(\mathsf{x}, 1, \mathsf{pre2}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}), \mathsf{post2}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}))(\mathsf{op})\ \{\\
\quad \mathbf{open}\ \mathsf{pre2}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\\
\quad \mathbf{open\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));\ \mathbf{open}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\\
\quad \mathsf{op}();\\
\quad *\mathsf{g2} \leftarrow_\mathsf{g} 1;\\
\quad \mathbf{close}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\ \mathbf{close\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));\\
\quad \mathbf{close}\ \mathsf{post2}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})()\\
\};
\end{array}}\\
\quad \ghost{\mathbf{close}\ \mathsf{pre2}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();}\\
\quad \mathbf{FAA}(\mathsf{x}, 1);\\
\quad \ghost{\mathbf{open}\ \mathsf{post2}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})()}\\
);\\
\ghost{\mathbf{destroy\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));}\\
\ghost{\mathbf{open}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();}\\
\mathbf{let}\ \mathsf{v} = {*}\mathsf{x}\ \mathbf{in}\\
\mathbf{assert}\ \mathsf{v} = 2
\end{array}$$
\caption{VeriFast proof of the example program. $\mathsf{Nx} \triangleq ()$.}\label{fig:example-proof}
\end{figure}

\begin{figure}
$$\begin{array}{l}
\annot{\{\mathbf{emp}\}}\\
\mathbf{let}\ \mathsf{x} = \mathbf{cons}(0)\ \mathbf{in}\ \ghost{\mathbf{glet}\ \mathsf{g1} = \mathbf{gcons}(0)\ \mathbf{in}}\ \ghost{\mathbf{glet}\ \mathsf{g2} = \mathbf{gcons}(0)\ \mathbf{in}}\\
\annot{\{\mathsf{x} \mapsto 0 * \mathsf{g1} \gmapsto 0 * \mathsf{g2} \gmapsto 0\}}\\
\ghost{\mathbf{close}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();}\\
\annot{\{\mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})() * [1/2]\mathsf{g1} \gmapsto 0 * [1/2]\mathsf{g2} \gmapsto 0\}}\\
\ghost{\mathbf{create\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));}\\
\annot{\{\mathbf{atomic\_space}(\mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 0 * [1/2]\mathsf{g2} \gmapsto 0\}}\\
(\\
\quad \annot{\{[1/2]\mathbf{atomic\_space}(\mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 0\}}\\
\quad \ghost{\begin{array}{@{} l @{}}
\mathbf{glet}\ \mathsf{lem} = \mathbf{produce\_lem\_ptr\_chunk}\ \mathsf{FAA\_ghop}(\mathsf{x}, 1, \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}), \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}))(\mathsf{op})\ \{\\
\quad \annot{\textrm{For all $\mathsf{P}, \mathsf{Q},$}}\\
\quad \annot{\{\mathbf{atomic\_spaces}(\emptyset) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, 1, \mathsf{P}, \mathsf{Q}) * \mathsf{P}() * \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})()\}}\\
\quad \mathbf{open}\ \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\\
\quad \annot{\left\{\begin{array}{l}
\mathbf{atomic\_spaces}(\emptyset) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, 1, \mathsf{P}, \mathsf{Q}) * \mathsf{P}() * {}\\
{}[1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 0
\end{array}\right\}}\\
\quad \mathbf{open\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));\ \mathbf{open}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\\
\quad \annot{\left\{\begin{array}{l}
\exists \mathsf{v2}.\;\mathbf{atomic\_spaces}(\{(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})\}) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, 1, \mathsf{P}, \mathsf{Q}) * \mathsf{P}() * {}\\
{}[1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * \mathsf{g1} \gmapsto 0 * [1/2]\mathsf{g2} \gmapsto \mathsf{v2} * \mathsf{x} \mapsto \mathsf{v2}
\end{array}\right\}}\\
\quad \annot{\textrm{For all $\mathsf{v2}$,}}\\
\quad \annot{\left\{\begin{array}{l}
\mathbf{atomic\_spaces}(\{(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})\}) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, 1, \mathsf{P}, \mathsf{Q}) * \mathsf{P}() * {}\\
{}[1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * \mathsf{g1} \gmapsto 0 * [1/2]\mathsf{g2} \gmapsto \mathsf{v2} * \mathsf{x} \mapsto \mathsf{v2}
\end{array}\right\}}\\
\quad \mathsf{op}();\\
\quad \annot{\left\{\begin{array}{l}
\mathbf{atomic\_spaces}(\{(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})\}) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, 1, \mathsf{P}, \mathsf{Q}) * \mathsf{Q}() * {}\\
{}[1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * \mathsf{g1} \gmapsto 0 * [1/2]\mathsf{g2} \gmapsto \mathsf{v2} * \mathsf{x} \mapsto 1 + \mathsf{v2}
\end{array}\right\}}\\
\quad *\mathsf{g1} \leftarrow_\mathsf{g} 1;\\
\quad \annot{\left\{\begin{array}{l}
\mathbf{atomic\_spaces}(\{(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})\}) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, 1, \mathsf{P}, \mathsf{Q}) * \mathsf{Q}() * {}\\
{}[1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * \mathsf{g1} \gmapsto 1 * [1/2]\mathsf{g2} \gmapsto \mathsf{v2} * \mathsf{x} \mapsto 1 + \mathsf{v2}
\end{array}\right\}}\\
\quad \mathbf{close}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();\ \mathbf{close\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));\\
\quad \annot{\left\{\begin{array}{l}
\mathbf{atomic\_spaces}(\emptyset) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, 1, \mathsf{P}, \mathsf{Q}) * \mathsf{Q}() * {}\\
{}[1/2]\mathbf{atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 1
\end{array}\right\}}\\
\quad \mathbf{close}\ \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})()\\
\quad \annot{\{\mathbf{atomic\_spaces}(\emptyset) * \mathsf{op} : \mathsf{FAA\_op}(\mathsf{x}, 1, \mathsf{P}, \mathsf{Q}) * \mathsf{Q}() * \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})()\}}\\
\};
\end{array}}\\
\quad \annot{\{[1/2]\mathbf{atomic\_space}(\mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 0 * \mathsf{lem} : \mathsf{FAA\_ghop}(\mathsf{x}, 1, \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}), \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}))\}}\\
\quad \ghost{\mathbf{close}\ \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();}\\
\quad \annot{\{\mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})() * \mathsf{lem} : \mathsf{FAA\_ghop}(\mathsf{x}, 1, \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}), \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}))\}}\\
\quad \mathbf{FAA}(\mathsf{x}, 1);\\
\quad \annot{\{\mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})() * \mathsf{lem} : \mathsf{FAA\_ghop}(\mathsf{x}, 1, \mathsf{pre1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}), \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}))\}}\\
\quad \ghost{\mathbf{open}\ \mathsf{post1}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})()}\\
\quad \annot{\{[1/2]\mathbf{atomic\_space}(\mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 1\}}\\
||\\
\quad \dots\\
);\\
\annot{\{\mathbf{atomic\_space}(\mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})) * [1/2]\mathsf{g1} \gmapsto 1 * [1/2]\mathsf{g2} \gmapsto 1\}}\\
\ghost{\mathbf{destroy\_atomic\_space}(\mathsf{Nx}, \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2}));}\ \ghost{\mathbf{open}\ \mathsf{Inv}(\mathsf{x}, \mathsf{g1}, \mathsf{g2})();}\\
\annot{\{\mathsf{g1} \gmapsto 1 * \mathsf{g2} \gmapsto 1 * \mathsf{x} \mapsto 2\}}\\
\mathbf{let}\ \mathsf{v} = {*}\mathsf{x}\ \mathbf{in}\\
\mathbf{assert}\ \mathsf{v} = 2
\end{array}$$
\caption{Proof outline for the example proof}\label{fig:example-outline}
\end{figure}

\bibliographystyle{plain}
\bibliography{verifasts-logic}

\end{document}
